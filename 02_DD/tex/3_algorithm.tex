\chapter{Algorithm design}


In this section we are going to outline the main algorithms that will govern our ecosystem. In fact, the application logic will reside in myTaxiService core system, whereas the applications myTaxiApp, myTaxiAssist and the website myTaxiWeb will be pure clients\footnote{``pure clients'' VA BENE?}. %TODO: "pure clients" va bene? 

Basically, the whole system has to manage the taxi queue of each area. As one may remember, the city is divided into small areas. While a taxi driver is waiting for a call in an area, his taxi is enlisted in the queue of that area: upon the reception of a request, the system forwards it to the first taxi in the queue of the area, according to the following algorithms.

First, let us make a brief theoretical introduction, for the sake of clarity. Notice that the word \emph{queue} has a technical meaning, which nevertheless corresponds to the common idea of a queue. This means that a queue is a data structure which models, for example, a line of customers waiting to pay a cashier. The queue has a head and a tail. When an element is inserted into the queue, it takes its place at the tail of the queue, just as a newly arriving customer takes a place at the end of the line. The element to be removed by the queue is always the one at the head of it, like the customer at the head of the line (who, by the way, has waited the longest). This is to say that the management policy of a queue is FIFO\footnote{FIFO stands for ``First In, First Out''.}. We call the insertion operation on a queue \emph{enqueue} (\fref[plain]{alg:enqueue}), and we call the deletion operation \emph{dequeue} (\fref[plain]{alg:dequeue}). 

We can now refer to the specific context of our project, in order to provide further details. Given an area, we consider its associated queue. Its elements will be taxis, and let us suppose that it can store at most $n-1$ of them, using an array $Q\left[1..n\right]$. The queue has an attribute $Q.head$ that indexes, or points to, its head. The attribute $Q.tail$ indexes the next location at which a newly arriving element will be inserted into the queue. When $Q.head = Q.tail$, the queue is empty, and initially, we have $Q.head = Q.tail = 1$. Finally, $Q.length$ is an attribute representing the length of the array $Q$, so $n = Q.length$ (notice that it does not store the actual number of elements in the queue, which is $Q.tail-1$ instead).

Now we are ready to present the two fundamental procedures that govern the system: \textsc{Enqueue} and \textsc{Dequeue}.

\newpage %TODO Remove

\begin{algorithm}\caption{Enqueue procedure.}
\label{alg:enqueue}\begin{algorithmic}[0]
\Procedure{Enqueue}{$Q$,$t$} \Comment{parameters: queue $Q$, taxi $t$.}
	\State $Q\left[Q.tail\right] \gets t$
	\If{$Q.tail = Q.length$}
		\State $Q.tail \gets 1$ \Comment{overflow case.}
	\Else
		\State $Q.tail \gets Q.tail + 1$
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\caption{Dequeue procedure.}
\label{alg:dequeue}\begin{algorithmic}[0]
\Procedure{Dequeue}{$Q$} \Comment{parameter: queue $Q$.} \label{procedu}
	\State $t \gets Q\left[Q.head\right]$
	\If{$Q.head = Q.length$}
		\State $Q.head \gets 1$
	\Else
		\State $Q.head \gets Q.head + 1$
	\EndIf
	\State \Return $t$ \Comment{dequeued taxi $t$ is returned.}
\EndProcedure
\end{algorithmic}
\end{algorithm}

Our system will make use of these procedures to do other things, for example when a taxi refuses a ride 

%TODO: Cosa se ne fa il sistema


%\begin{algorithm}%\caption{Euclid's algorithm}\label{euclid}%\begin{algorithmic}[0]%\Procedure{Euclid}{$a,b$}\Comment{The g.c.d. of a and b}%   \State $r\gets a\bmod b$%   \While{$r\neq 0$}\Comment{We have the answer if r is 0}%      \State $a\gets b$%      \State $b\gets r$%      \State $r\gets a\bmod b$%   \EndWhile\label{euclidendwhile}%   \State \textbf{return} $b$\Comment{The gcd is b}%\EndProcedure%\end{algorithmic}%\end{algorithm}